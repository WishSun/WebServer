# 处理客户端请求流程  
![](https://i.imgur.com/DWcTlr7.png)  

## 注解:  
1. **Epoll监听到客户端数据到来，即客户端套接字描述符就绪**  

2. **读取客户端请求**  
	- 调用http_conn::read\_request()方法来读取客户端请求到http\_conn::m\_read\_buf缓冲区中  

3. **将客户端连接的http\_conn对象添加到线程池任务队列**  
	- 读取到一个客户端请求后(可以不完整，但不能有语法错误)，将该http\_conn对象添加到线程池任务队列中
	- 线程池工作线程获取任务对象后，然后开始调用任务对象的process()方法，这个接口是线程池规定任务类必须实现的，线程池的工作线程将调用它来执行任务。  

4. **判断是否读入了一个完整的行**  
	- 因为添加到线程池中的任务对象的请求可能是不完整的，在process方法内首先查看是否是一个完整的行，即碰到\r\n  
	- 如果没有读到完整的行，说明本行数据没有读完，则继续去监听客户端数据，即转到步骤1, 如果读到了一个完整的行，则继续分析。  

5. **分析请求行**  
	- 分析请求行，获取请求方法，URL，以及协议版本  

6. **分析请求头部**  
	- 分析请求头部，获取头部字段值，包括Connection、host以及Content\-length等等。  

7. **判断是GET请求还是POST请求。**
	- 通过分析请求行，获取到的请求方法来判断  

8. **处理GET请求**  
	- 根据URL获取到请求文件名，然后根据服务器文件存储目录构造出真实路径。  
	- 对请求文件的属性进行分析，看其存不存在，存在的话并获取它的大小字节数。  
	- 将文件映射到内存空间，并记录映射地址。  
	- 然后开始制作GET请求响应头部  
	- 响应头部制作完毕后注册客户端的可写事件EPOLLOUT，此时工作线程的任务就结束了。而真正的向客户端发送响应是交给监听线程来完成的。  

9. **处理POST请求**  
	- 如果查看到请求方法为POST，且Content\-length字段不为空，则去处理POST请求。
	- 当前进程创建两个管道:
		- 管道fa\_To\_ch(父进程向子进程传递参数) 
		- 管道ch\_To\_fa(子进程向父进程传递结果)
	- 创建子进程。 关闭子进程对fa\_To\_ch管道的写端，关闭ch\_To\_fa管道的读端，并将标准输入STDIN\_FILENO重定向到fa\_To\_ch管道的读端，这样子进程通过读标准输入即可获取到父进程通过fa\_To\_ch管道传递给子进程的数据。 将标准输出STDOUT\_FILENO重定向到ch\_To\_fa管道的写端，这样子进程就可以通过标准输出向父进程发送处理结果。  
	- 用CGI程序替换进程空间，通过环境变量将POST请求方法和参数长度传递给CGI子进程。  
	- 父进程通过读取ch\_To\_fa管道获取CGI进程的处理结果，并转发给客户端套接字。
